{"ast":null,"code":"import { BODY_CHARACTERS_PER_LINE, CHARACTERS_TO_REMOVE, LINES_PER_PAGE, SUBTITLE_CHARACTERS_PER_LINE } from \"../constant/Constants\";\nexport function getPoemFromRows(rows) {\n  return rows.toJS();\n}\n\n// For English or Hindi, we can fit more letters.\nfunction getFontWidthMultiplier(subtitle) {\n  const englishRegex = /^[A-Za-z0-9]/;\n  if (englishRegex.test(subtitle)) {\n    return 2.0;\n  }\n  return 1.0;\n}\nfunction getLineFromPoem(poem) {\n  const {\n    title,\n    subtitle,\n    body\n  } = poem;\n  if (title !== \"\") {\n    poem.title = \"\";\n    let remainingSubtitleLength = (SUBTITLE_CHARACTERS_PER_LINE - title.length * 2 - 5) * 2 * getFontWidthMultiplier(subtitle);\n    if (subtitle.length <= remainingSubtitleLength) {\n      poem.subtitle = \"\";\n      return {\n        title,\n        subtitle,\n        body: \"\"\n      };\n    } else {\n      const includedSubtitle = poem.subtitle.slice(0, remainingSubtitleLength);\n      poem.subtitle = poem.subtitle.slice(remainingSubtitleLength);\n      return {\n        title,\n        subtitle: includedSubtitle,\n        body: \"\"\n      };\n    }\n  }\n\n  // title has been processed\n  if (subtitle !== \"\") {\n    let remainingSubtitleLength = SUBTITLE_CHARACTERS_PER_LINE * 2 * getFontWidthMultiplier(subtitle);\n    if (subtitle.length <= remainingSubtitleLength) {\n      poem.subtitle = \"\";\n      return {\n        title,\n        subtitle,\n        body: \"\"\n      };\n    } else {\n      const includedSubtitle = poem.subtitle.slice(0, remainingSubtitleLength);\n      poem.subtitle = poem.subtitle.slice(remainingSubtitleLength);\n      return {\n        title,\n        subtitle: includedSubtitle,\n        body: \"\"\n      };\n    }\n  }\n\n  // title and subtitle have both been processed\n  let displayLength = 0;\n  let totalLength = 0;\n  const removeSet = new Set(CHARACTERS_TO_REMOVE);\n  for (totalLength = 0; totalLength < body.length; totalLength++) {\n    const char = body[totalLength];\n    if (char === \"\\r\") {\n      break;\n    }\n    if (!removeSet.has(char)) {\n      displayLength++;\n    }\n    if (displayLength === BODY_CHARACTERS_PER_LINE) {\n      if (totalLength < body.length - 1 && removeSet.has(body[totalLength + 1])) {\n        totalLength++;\n      }\n      totalLength++;\n      break;\n    }\n  }\n  if (body.length === totalLength) {\n    poem.body = \"\";\n    return {\n      title,\n      subtitle,\n      body\n    };\n  } else {\n    const includedBody = poem.body.slice(0, totalLength);\n    let remainingBody = poem.body.slice(totalLength);\n    if (remainingBody.startsWith(\"\\r\")) {\n      remainingBody = remainingBody.slice(2);\n    }\n    poem.body = remainingBody;\n    return {\n      title,\n      subtitle,\n      body: includedBody\n    };\n  }\n}\nexport function getLinesFromPoems(poems) {\n  if (poems.length === 0) {\n    return [];\n  }\n  const lines = [];\n  for (const poem of poems) {\n    const poemClone = {\n      ...poem\n    };\n    while (poemClone.body !== \"\") {\n      const line = getLineFromPoem(poemClone);\n      lines.push(line);\n    }\n  }\n  return lines;\n}\nexport function getPagesFromLines(lines) {\n  const pages = [];\n  for (let i = 0; i < lines.length; i += LINES_PER_PAGE) {\n    const page = lines.slice(i, i + LINES_PER_PAGE);\n    pages.push(page);\n  }\n  return pages;\n}","map":{"version":3,"names":["BODY_CHARACTERS_PER_LINE","CHARACTERS_TO_REMOVE","LINES_PER_PAGE","SUBTITLE_CHARACTERS_PER_LINE","getPoemFromRows","rows","toJS","getFontWidthMultiplier","subtitle","englishRegex","test","getLineFromPoem","poem","title","body","remainingSubtitleLength","length","includedSubtitle","slice","displayLength","totalLength","removeSet","Set","char","has","includedBody","remainingBody","startsWith","getLinesFromPoems","poems","lines","poemClone","line","push","getPagesFromLines","pages","i","page"],"sources":["/Users/liqian/projects/tianyahaige/src/adaptor/ContentAdaptor.ts"],"sourcesContent":["import {\n    BODY_CHARACTERS_PER_LINE,\n    CHARACTERS_TO_REMOVE,\n    LINES_PER_PAGE,\n    SUBTITLE_CHARACTERS_PER_LINE,\n} from \"../constant/Constants\";\nimport { Line, Page, Poem } from \"../type/Types\";\nimport { List } from \"immutable\";\n\nexport function getPoemFromRows(rows: List<Poem>): Poem[] {\n    return rows.toJS();\n}\n\n// For English or Hindi, we can fit more letters.\nfunction getFontWidthMultiplier(subtitle: string) {\n    const englishRegex = /^[A-Za-z0-9]/;\n    if (englishRegex.test(subtitle)) {\n        return 2.0;\n    }\n    return 1.0;\n}\n\nfunction getLineFromPoem(poem: Poem): Line {\n    const { title, subtitle, body } = poem;\n\n    if (title !== \"\") {\n        poem.title = \"\";\n\n        let remainingSubtitleLength =\n            (SUBTITLE_CHARACTERS_PER_LINE - title.length * 2 - 5) *\n            2 *\n            getFontWidthMultiplier(subtitle);\n\n        if (subtitle.length <= remainingSubtitleLength) {\n            poem.subtitle = \"\";\n            return {\n                title,\n                subtitle,\n                body: \"\",\n            };\n        } else {\n            const includedSubtitle = poem.subtitle.slice(\n                0,\n                remainingSubtitleLength\n            );\n            poem.subtitle = poem.subtitle.slice(remainingSubtitleLength);\n            return {\n                title,\n                subtitle: includedSubtitle,\n                body: \"\",\n            };\n        }\n    }\n\n    // title has been processed\n    if (subtitle !== \"\") {\n        let remainingSubtitleLength =\n            SUBTITLE_CHARACTERS_PER_LINE * 2 * getFontWidthMultiplier(subtitle);\n\n        if (subtitle.length <= remainingSubtitleLength) {\n            poem.subtitle = \"\";\n            return {\n                title,\n                subtitle,\n                body: \"\",\n            };\n        } else {\n            const includedSubtitle = poem.subtitle.slice(\n                0,\n                remainingSubtitleLength\n            );\n            poem.subtitle = poem.subtitle.slice(remainingSubtitleLength);\n            return {\n                title,\n                subtitle: includedSubtitle,\n                body: \"\",\n            };\n        }\n    }\n\n    // title and subtitle have both been processed\n    let displayLength = 0;\n    let totalLength = 0;\n    const removeSet = new Set(CHARACTERS_TO_REMOVE);\n    for (totalLength = 0; totalLength < body.length; totalLength++) {\n        const char = body[totalLength];\n        if (char === \"\\r\") {\n            break;\n        }\n        if (!removeSet.has(char)) {\n            displayLength++;\n        }\n        if (displayLength === BODY_CHARACTERS_PER_LINE) {\n            if (\n                totalLength < body.length - 1 &&\n                removeSet.has(body[totalLength + 1])\n            ) {\n                totalLength++;\n            }\n            totalLength++;\n            break;\n        }\n    }\n\n    if (body.length === totalLength) {\n        poem.body = \"\";\n        return {\n            title,\n            subtitle,\n            body,\n        };\n    } else {\n        const includedBody = poem.body.slice(0, totalLength);\n        let remainingBody = poem.body.slice(totalLength);\n        if (remainingBody.startsWith(\"\\r\")) {\n            remainingBody = remainingBody.slice(2);\n        }\n        poem.body = remainingBody;\n        return {\n            title,\n            subtitle,\n            body: includedBody,\n        };\n    }\n}\n\nexport function getLinesFromPoems(poems: Poem[]): Line[] {\n    if (poems.length === 0) {\n        return [];\n    }\n\n    const lines: Line[] = [];\n\n    for (const poem of poems) {\n        const poemClone = { ...poem };\n        while (poemClone.body !== \"\") {\n            const line = getLineFromPoem(poemClone);\n            lines.push(line);\n        }\n    }\n\n    return lines;\n}\n\nexport function getPagesFromLines(lines: Line[]): Page[] {\n    const pages = [];\n\n    for (let i = 0; i < lines.length; i += LINES_PER_PAGE) {\n        const page = lines.slice(i, i + LINES_PER_PAGE);\n        pages.push(page);\n    }\n\n    return pages;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}